=== Pulled-out-of-thin-air Plan ===

November 1st (Start date)
1. Read up on the state-of-the-art.
	Two weeks - aim to have read and understood 6 or 7 papers. Write some code implementing some algorithms to feel convinced that 
	I've well understood it. There is a lot of coursework during this period.

November 15th
2. Research current in-memory representations of graph databases.
	Two weeks - I should be familiar with at least one regular format in which data is stored by modern graph databases. Hopefully 
	more than one though. Again, there is lots of coursework, as well as an intersection with the group project deadline.

November 29th
3. For a given query determine the fix-point for the database. Attempt a prove that this is in fact optimal.
	Three weeks - It is probably not going to be easy, but it's difficult to predict just how difficult it will be. This time period 
	intersects the main exam revision period and Christmas, hence a defensive time allocation.
Delivery: Some proven properties of the fix-point of a graph database under a defined workload.

December 20th
4. Develop algorithms which ensure that queries to the database bring the structure closer to the fix-point. Attempt to prove that they 
   do.
	Three weeks - As above, definitely won't be easy, not sure how long this will take me and again three weeks is basically a  
	random guess.
Delivery: At least one proven implementable algorithm for moving a graph database towards it's fix-point under a defined workload.

=== Note that below this line I don't have coursework dates - so all allocations must be defensive to account for this risk ===

January 10th
5. Implement cracking for a RDB.
	Three weeks - Write a minimal program implementing cracking on an RDB in a high performance language (probably Rust).
Delivery: A program which performs as a queriable in-memory column store, implementing the cracked select, update and join operations. Maybe it will also implement cracking across mutliple columns. This should be demoed.

January 31st
6. Model a graph database system on the RDB.
	Two days - Adjacency table + Vertex table. It will probably not turn out to be this easy.
Delivery: A column store represented in the previously created program with two tables: An adjacency table and a vertex table, which should be demoed to be queriable and updatable.

Febraury 2nd
7. Implement some graph algorithms on the cracked graph wrapped RDB.
	Three days - Page rank is not a very complex algorithm and this should not be difficult if I am not lazy.
Delivery: A function within the previously created program which for a pair of tables G = (V, E) will compute the page rank of each vertex. This should be demoed for more than one input graph.

Febraury 5th
8. Get/generate some data for running some graph algorithms with a non-trivial running time.
	Three days - I'm not sure how I would do this off the top of my head. Defensive allocation of two days for researching how to 
	produce a good dataset for this test - it will be important.

Febraury 8th
9. Run some performance benchmarks with the graph algorithm implementations on the cracked RDB using the data.
	One day - Should be as simple as running `time ./runPagerankRDB`
Delivery: Some running times for the pagerank implementation.

Febraury 9th
10. Implement a minimal graph database and the algorithms defined earlier in some high-performance programming language (probably Rust)
	Six weeks - This sounds pretty difficult, especially compounded with my inexperience in high performance programming. I'm not 
	really sure how long it will take. Six weeks is a long time, but who knows how much of a challenge it will present.
Delivery: A progam which acts as a queriable, updateable graph database, implementing the performance improving algorithms defined earlier in the project. This should be demoed and it should also be shown that the algorithms do indeed make it faster in the expected way.

March 23rd
11. Implement the earlier graph algorithms using this system.
	Two weeks - There will likely be issues with the implementation that will reveal themselves at this stage and need ironing out, 
	hence a more defensive time allocation.
Delivery: A program conforming to the same specification as the one produced in step 7.

April 6th
12. Run performance benchmarks using the same data used to benchmark the RDB system.
	Three days - As before, this should be as straightforward as running a bash timing script on an executable.
Delivery: Running times produced in the same way as in step 9. If all has gone well, these new ones will be faster.

April 9th
13. Write up findings
	Four weeks - Many drafts will be needed and it will be quite a lot of writing I imagine to get a refined result, requiring many
	hours of effort.
Delivery: A well written report with correct references, good diagrams and clear explanations. It should be a report worthy of all the hard work up to this point.

May 7th
14. Finished

Lower bound on completion date: May 7th
Christmas, New year, being ill, hangovers: Two week allowance
Upper bound on completion date: May 21st

Hard deadline: June 18th

Failure tolerance (from lower bound): 28 days.
