Statement:

For an array of numbers, col, where we are attempting to select a range of
numbers between low and high with inclusivity specified by inc_l and inc_h:

// TODO: Simplify this?
(1) uC = under catchment = {x | x ϵ col ^ (inc_l ⇒ x < low)  ^ (¬inc_l ⇒ x <= low)}
(2) iC = in catchment    = {x | x ϵ col ^ (inc_l ⇒ x >= low) ^ (¬inc_l ⇒ x > low) ^ (inc_h ⇒ x <= high) ^ (¬inc_h ⇒ x < high)}
(3) oC = over catchment  = {x | x ϵ col ^ (inc_h ⇒ x > high) ^ (¬inc_h ⇒ x >= high)}

We wish to show that when calling cracker_select_in_three such that:

(4) pos_l <  pos_h < col.len()
(5) low < high

At the time of the function returning, the following will hold:

(6) ∀ pos_l <= i < p_low: col[i] ϵ uC
(7) ∀ p_low <= i <= p_itr: col[i] ϵ iC
(8) ∀ pos_h >= i > p_itr: col[i] ϵ oC

Body:

We first show that for (9) x ϵ col

(10) c_low(x)  ⇔ x ϵ uC
(11) c_high(x) ⇔ x ϵ oC

c_low(x) ⇔ x < low + !inc_l as i64
         ⇔ inc_l  ⇒ (c_low(x) ⇔ x < low + 0)
         ⇔ inc_l  ⇒ (c_low(x) ⇔ x < low)
         ^ ¬inc_l ⇒ (c_low(x) ⇔ x < low + 1)
         ⇔ ¬inc_l ⇒ (c_low(x) ⇔ x <= low)
c_low(x) ⇔ (inc_l ⇒  x < low) ^ (¬inc_l ⇒  x <= low)

From (1), (9) and the above result, we have (10)

c_high(x) ⇔ x > high - !inc_h as i64
          ⇔ inc_h  ⇒ (c_high(x) ⇔ x > high - 0)
          ⇔ inc_h  ⇒ (c_high(x) ⇔ x > high)
          ^ ¬inc_h ⇒ (c_high(x) ⇔ x > high - 1)
          ⇔ ¬inc_h ⇒ (c_high(x) ⇔ x >= high)
c_high(x) ⇔ (inc_h ⇒  x > high) ^ (¬inc_h ⇒  x >= high)

From (3), (9) and the above result, we have (11)

Next we record that just before entering the main loop:

(12) ∀ pos_l <= i < p_low:  col[i] ϵ uC
(13) ∀ pos_h >= i > p_high: col[i] ϵ oC

This is trivially obvious from the two while loops and by
considering the case where the condition is not satisfied
initially, that is, the while loop doesn't even run once.

Within the main loop:

We now show that whenever the loop condition is checked,
the following hold:



